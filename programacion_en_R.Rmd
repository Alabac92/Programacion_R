---
title: "Programacion en R"
author: "Alfredo Aburto Alcudia: Curso de analisis de datos con Google"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true # Mostrar tabla de contenido en documento R markdown
    toc_depth: 5 # Niveles de la tabla de contenidoo
    toc_float: true # Mostrar la tabla de contenido en todo el documento
    collapsed: true # Si solo queremos que muestre el nivel principal
    smooth_scroll: true # Reflejar nuestra ubicación en barra de contenido
    theme: journal # Estilo del documento
    highlight: kate # Estilo del codigo
    df_print: paged # Estilo para mostrar los datos
    code_folding: show # Mostrar o no el código del documento
---

<div style="text-align: justify;">

## Introducción
El presente documento tiene como objetivo mostrar las notas realizadas durante
la formación de Google como analista de datos junior. Lo anterior, con el fin
de fungir como guía de consulta en temas básicos y como última instancia
prácticar en la utilización de R markdown para la creación de informes. Ya que
anteriormente todas las descripciones teoricas se habian realizado como 
comentarios sobre archivos de extension ".R".

## Estructuras de datos en R
Una forma de crear una vector es utilizar la función c()
llamada función "combinar"
Los vectores atómicos solo pueden contener elementos del mismo
tipo.

### Vectores
#### Definición de un vector númerico
```{r vector_numeric}
vector_01 <- c(2.5,4.9,1.3)
vector_01
```

#### Definición de un vector de números enteros
```{r vector_numeros_enteros}
vector_02 <- c(2L, 3L, 9L)
vector_02
```

#### Definición de un vector de caracteres y valores logicos
```{r vectores_caracter_logicos}
vector_03 <- c("Ciencia", "Datos", "Tecnología")
vector_03
vector_04 <- c(TRUE, TRUE, FALSE, TRUE, FALSE, FALSE)
vector_04
```

### DETERMINAR PROPIEDADES DE VECTORES (Tipo y longitud)
#### Determinar el tipo de vector con el que se trabaja
```{r tipo_vector}
typeof(vector_03)
```

#### Verificar si un vector es de un tipo específico usando la función 'is'
```{r funcion_is}
is.logical(vector_02)
is.integer(vector_02)
```

#### Determinar la longitud del vector
```{r longitud_vector}
length(vector_04)
```

#### Asignación de nombres a los elementos de un vector

Definimos el vector x como ejemplo
```{r vector_ejemplo01}
x <- c(1, 3, 5)
```

Asignamos nombres a cada elemento del vector x con la función 'names()'

```{r funcion_names}
names(x) <- c("a", "b", "c")
x # Pasamos por consola el vector x
```
La asignación de nombres a los elementos de un vector puede ser útil para hacer 
que el código sea más legible y comprensible, ya que puedes referirte a los elementos 
por sus nombres en lugar de sus índices. Por ejemplo, para acceder al elemento 
"c" del vector x
```{r}
x["c"]
```
Con lo anterior enviamos por pantalla al elemento c del vector x

### LISTAS
Las listas difieren de los vectores atómicos porque sus elementos pueden ser de 
cualquier tipo. Además las listas pueden contener a otras listas.

#### Definición de una lista utilizando la funcion list()
```{r funcion_list}
lista_01 <- list("alfredo", 17L, 8.3, FALSE)
lista_01
```

#### Definición de listas anidadas
```{r list_02}
lista_02 <- list(2L, 3.9273, "a", TRUE, list("b", FALSE))
lista_02
```

#### Determinar la estructura de una lista
Si se desea saber qué tipos de elementos contiene una lista, puedes utilizar 
la función str().
```{r funcion_str}
str(lista_02)
```
Al ejecutar la función str(), R mostrará la estructura de datos de la lista 
mediante la descripción de sus elementos y tipos

#### Nombrando los elementos de una lista
Al igual que con los vectores, podemos nombrar los elementos de una
lista, asignandole a cada elemento un nombre cuando definimos la lista.

```{r nombrando_elementos_lista}
lista_03 = list('Temperatura (K)' = 20.5, "Presion (atm)" = 1L)
lista_03 # Enviamos por pantalla lista_03
```
___
## Fechas y horas
Para trabajar con fechas y horas utilizammos el paqute lubridate. Para ello es
necesario instalar y cargar los paquetes tidyverse y lubridate el cual es parte
de tidyverse
 - Instalacion de paquete tydyverse

```{r instalacion_tydiverse}
install.packages("tidyverse")
```

 - Carga de paquetes tidyverse y lubridate utilizando la función 'library()'
```{r carga_tidyverse}
library(tidyverse)
```

Lubridate es un paquete diseñado para trabajar con fechas y horas de una manera
más sencilla y cómoda. Algunas de las funciones y características clave incluyen:
- Parseo de fechas: Facilita la conversión de texto a objetos de fecha y hora.
- Manipulación de fechas: Proporciona funciones para extraer y manipular 
componentes de fechas, como días, meses, años, horas  y minutos.
- Operaciones con fechas: Permite realizar cálculos y operaciones entre fechas
de manera intuitiva.
- Manejo de zonas horarias: Facilita el trabajo con zonas horarias y la 
conversión entre ellas.

### Trabajando con fechas y horas

#### Tipos
En R hay tres tipos de datos que hacen referencia a un instante en el tiempo
- Fecha: ("2002-10-17")
- Hora de un dia: ("23:54:46 UTC")
- Fecha-hora: ("2010-04-25 16:12:05 UTC")

La hora se expresa en UTC, que quiere decir Hora Universal Coordinada, más 
comúnmente conocida como tiempo civil. Este es el estándar principal que 
regula los relojes y  la hora mundial.

Obtener la fecha actual (mes, año, día)
```{r funcion_today}
today()
```

Obtener fecha y hora actual

```{r funcion_now}
now()
```
Al trabajar con R, hay tres modos posibles de crear formatos de fecha-hora: 
- Desde una cadena
- Desde una fecha individual
- Desde un objeto de fecha/hora existente

R crea fechas en el formato estándar yyyy-mm-dd (año-mes-día) por defecto.

#### Convertir a partir de una cadena
Los datos de fecha/hora a menudo se expresan como cadenas. 
Puedes convertir cadenas en fechas y fecha-hora utilizando 
las herramientas provistas por lubridate. Estas herramientas
automáticamente trabajan sobre el formato de fecha/hora. 

1. Primero, identifica el orden en el año, el mes y el día que aparecen en tus 
fechas.

2. Ordena las letras y, m y d (año, mes y día) en el mismo orden. Eso te dará el 
nombre de la función lubridate que analizará tu fecha.

Por ejemplo, para la fecha 2021-01-20, utilizarás el orden ymd:

```{r}
fecha_01 <- ymd("2021-01-20")
fecha_01 # Enviamos por pantalla fecha_01
```

mdy Febrero 20th, 2023
```{r}
fecha_02 <- mdy("Febrero 20th, 2023")
fecha_02
```

Estas funciones también toman números que no están entre comillas y los 
convierte al formato yyyy-mm-yy.

```{r}
fecha_03 <- ymd(20210120)
fecha_03
```

#### Crear componentes de fecha-hora

La función ymd() y sus variantes crean fechas. Para crear una fecha-hora desde 
una fecha, agrega un guion bajo y una o más de las 
letras h, m y s (horas, minutos y segundos) al nombre de la función:

```{r}
fecha_04 <- ymd_hms("2021-01-20 20:11:59")
fecha_04
```

Notar el orden en el que se ponen las letras en la función

```{r}
fecha_05 <- ymd_hms("2021-01-20 20:11:59")
fecha_05
```

#### Cambiar entre objetos existentes de fecha-hora
Quizas se quiera cambiar entre una fecha-hora y una fecha. Se puede utilizar la
función as_date() para convertir una fecha-hora en una fecha.

```{r funcion_as_date}
fecha_06 <- as_date(now())
fecha_06
```

## Organizar datos
Si nuestra información no esta ordenada no podemos transformar la información
en conocimiento. Ordenar nuestros datos nos permite conocer nuevos detalles
de nuestros datos.

Para lograrlo utilizaremos las funciones:
- arrange()
- group_by()
- filter()

1. Inserta el paquete tidyverse para poder utilizar su núcleo
2. Obtención de conjunto de datos
```{r conjunto_palmerpenguins}
install.packages("palmerpenguins")
```
3. Cargamos nuestros datos
```{r}
library(palmerpenguins)
```

**Ordenar datos por una columna especifica en este caso longitud de su pico**

Los siguientes comandos crean un **tibble** y es importante recordar que
estos comandos NO modifican mi conjunto de datos, solo estan temporalmente por
pantalla

```{r orden_ascendente}
penguins %>% arrange(bill_length_mm) # Ordena ascendentemente
```
```{r orden_descendente}
penguins %>% arrange(-bill_length_mm) # Ordena descendente añandiendo "-"
```

Si deseamos crear un nuevo marco de datos que contenga los datos ordentados
seguiremos el siguiente ejemplo, con él logramos guardar datos limpios sin
perder infromación del conjunto de datos original

```{r guardar_datos_ordenados}

penguins_bill_descen <- penguins %>% arrange(-bill_length_mm)
View(penguins_bill_descen)

```

### group_by()

Esta función suele combinarse con otras funciones, nos permite agrupar por
alguna columna en particular y luego realizar una operación esos grupos

- Creamos nuestro grupo
```{r}
penguins %>% 
  group_by(island) %>% # Agrupamos por isla
  drop_na() %>% # Eliminamos filas con valores nulos en cualquier columna
  summarise(mean_bill_length_mm = mean(bill_length_mm))
```
En el fragmento anterior la función summarise se utiliza para resumir los datos
dentro de cada grupo, en este caso, calculando la media de una columna especifica.

Otro ejemplo de uso
```{r}
penguins %>% 
  group_by(island) %>% 
  drop_na() %>% 
  summarise(max_bill_length_mm = max(bill_length_mm))
```

Podemos utilizar tanto group_by como summarise para realizar los dos ejemplos
anteriores simultasneamente:

```{r funcion_summarise}
penguins %>% 
  group_by(species, island) %>% 
  drop_na() %>% 
  summarise(max_bl = max(bill_length_mm), mean_bl = mean(bill_length_mm))
```

El fragmento anterior logra realizar varias tareas de limpieza gracias al uso 
de la canalización o pipes, el resultados es un conjunto de datos que muestra
la longitud máxima del pico y el promedio de la longitud del pico por especie
que se encuentra en cada isla.

### filter()
Supongamos que deseamos obtener solo los datos sobre los pinguinos Adelie.

```{r funcion_filter}
penguins %>% 
  filter(species == "Adelie") # Exactamente igual a la especia Adelie
```

## Transformación de Datos
A veces necesitamos dividir una variable entre múltiples columnas o
combinar las columnas atuales, o incluso agregar nuevos valores a el 
marco de datos. Las funciones básicas incluyen:

- separate()
- unite()
- mutate()

**Creamos un marco de datos desde cero**

```{r creacion_manual_dataframe}
id <- c(1:10)
name <- c("John Mendes", "Rob Stewart", "Rachel Abrahamson", "Christy Hickman", 
          "Johnson Harper", "Candace Miller", "Carlson Landy", "Pansy Jordan", 
          "Darius Berry", "Claudia Garcia")

job_title <- c("Professional", "Programmer", "Management", "Clerical", "Developer",
               "Programmer", "Management", "Clerical", "Developer", "Programmer")

employee <- data.frame(id, name, job_title)

print(employee)
```

### separate()
Permite separar datos de un data frame de una columna en especifico con algun
separador que podamos encontrar por ejemplo un espacio

```{r funcion_separate}
employee_separate <- separate(employee, name, into=c("first_name", "last_name"), sep=" ")
employee_separate
```

Con la función anterior decimos "del data-frame employee en la columna name
separa el contenido de cada fila en dos columnas, el primer elemento de la 
separación lo colocas en la columna "first_name" y el segundo elemento en
la columna "last_name", para encontrar cada elemento debes buscar un espacio
en blanco como caracter de separacion.

La función separate tiene un aliado, la función unite.

### unite()
Esta función nos permite fusionar columnas entre sí, es decir, lo opuesto a la
funcion separate.

**Trabajando con el data.frame con dos columnas de nombre**
```{r funcion_unite}
unite(employee_separate, 'name', first_name, last_name, sep=" ")
```

Con la funcion anterior decimos "Usa el data frame employee_separate, nombra la
columna donde se juntaran las columnas como 'name, une las columnas 'first_name',
y 'last_name' y separalos con un espacio"

### mutate()

La función mutate()permite agregar una columna de datos es decir una nueva
variable.
```{r}
install.packages("palmerpenguins")
library(palmerpenguins)
data('penguins')
View(penguins)
```

En este dataset, la masa de los pinguinos se encuentra en gramos. Por lo que
crearemos una nueva columna con la masa corporal en kg


```{r funcion_mutate}
penguins %>% 
  mutate(body_mass_kg = body_mass_g/1000, flipper_length_m=flipper_length_mm/1000)
```

### Mismos datos diferentes resultados

Instalamos el paquete donde se encuentra el data set sobre el
cuarteto de Anscombe
```{r}
install.packages('Tmisc')
```

Cargamos los datos
```{r}
library(Tmisc)
data(quartet)
View(quartet)
```

Este conjunto de datos contiene 4 conjuntos de ejex x e y.
Los datos se pueden resumir a través de diferentes parametros estadisticos.
Obtendremos un resumen de cada conjunto de datos con la media, desvest y la
correalacion.

Cargamos paquetes necesarios para usar summarize

```{r instala_dplyr}
install.packages("dplyr")
library(dplyr)
```
```{r}
quartet %>% 
  group_by(set) %>% 
  summarize(mean(x), sd(x), mean(y), sd(y), cor(x, y))
```

Al observar la salida del comando anterior podemos ver que tanto la media,
como la desviacion estandar y la correlacion entre las variables x e y en 
cada cuadrante es identica. Pero mirar unicamente el resumen estadistico puede
resultar engañoso. Para notar esto, creaeremos algunos gráficos:

```{r}
ggplot(quartet,aes(x,y)) + geom_point() + geom_smooth(method=lm, se=FALSE) + 
  facet_wrap(~set)
```

Los gráficos generados muestran las grandes diferencias que hay para cada 
cuadrante
</div>